---
title: Exam Style Questions - System software
sidebar_label: ESQ
slug: esq
sidebar_position: 2
---

## Question 1

#### a) In a multiprogramming environment, the concept of a process has been found to be very useful in controlling the execution of programs.

#### i Explain the concept of a process

- a program that has begun execution
- a program in memory that has an associated process control block
- a process is an independent unit of execution that represents a program in execution
- it includes the program code, current execution state, and allocated system resources
- processes allow for concurrent execution, isolation between tasks, and efficient resource management

#### ii In one model for the execution of a program, there are five defined process states. Identify three of them and explain the meaning of each.

- Ready: The process is prepared to execute but is waiting for the CPU to be assigned by the scheduler.
- Running: The process is currently being executed by the CPU.
- Blocked/Waiting: The process is temporarily halted, often waiting for an event or resource (e.g., I/O operation) before it can proceed.

#### b) The transition of processes between states is controlled by a scheduler

#### i Identify two scheduling algorithms and for each classify its type

1. Round Robin (RR)

   - Preemptive
   - Round Robin is a preemptive scheduling algorithm where each process is assigned a fixed time slot (time quantum). When a time quantum expires, the process is moved to the back of the queue, and the next process in the queue is given CPU time.

2. First-Come-First-Serve (FCFS)

   - Non-preemptive
   - FCFS is a non-preemptive scheduling algorithm where the process that arrives first is the first to be executed. Once a process starts its execution, it continues until it completes or is blocked, without interruption by the scheduler.

#### ii A scheduling algorithm might be chosen to use prioritisation. Identify two criteria that could be used to assign a priority to a process

- estimated time of process execution (when the time taken to complete the required process is very low (shorter burst times))
- estimated remaining time for execution
- length of time already spent in the ready queue
- whether the process is I/O bound or CPU bound.

## Question 2

#### a) Three memory management techniques are partitioning, scheduling and paging.

#### i Give definitions of them

- partitioning: dividing the physical memory into fixed-size or variable-size partitions to accommodate multiple processes
- scheduling: determining the order in which processes or tasks are executed by the CPU. Examples of some scheduling algorithms are: First-Come-First-Serve (FCFS), Round Robin (RR)
- paging: The process is divided into equal-sized pages and memory is divided into frames of the same size. The secondary storage can also be divided into frames.

#### b) Some systems use virtual memory.

#### i Identify which of the techniques in part a is used to create virtual memory

- paging

#### ii Explain two advantages of using virtual memory.

- Increased Address Space: Virtual memory provides a larger address space than physical RAM, accommodating larger programs.
- Multitasking: Enables concurrent execution of multiple processes, improving system efficiency.
- Memory Isolation: Protects processes from interfering with each other, enhancing system stability and security.
- Demand Paging: Efficiently loads only necessary program portions into memory, reducing I/O operations and improving performance.
- Ease of Memory Management: Simplifies memory allocation, allowing flexible use of resources.

#### Explain one problem that can occur in a virtual memory system

- page faults can occur when a program tries to access a page that is not currently in the physical memory
- this leads to additional time and resources being spent to bring the required page into memory
- causing a delay in the execution

## Question 3

#### a) A compiler is used to translate a program into machine code.

#### i A compiler is modelled as containing a front end and a back end. State the overall aim of the front end and of the back end.

- Front End

  - responsible for analyzing the source code
  - understand and represent the program's structure and meaning in an intermediate form
  - it does lexical analysis, syntax analysis, semantic analysis, and the creation of an intermediate representation

- Back End
  - takes the intermediate representation generated by the front end and translates it into the target machine code
  - focuses on code optimization, code generation, and the production of an executable output that can run on the target platform's hardware
  - aims to produce efficient and optimized machine code to the specific architecture

#### ii Identify two processes which are part of the front end.

- lexical analysis: breaking the source code into tokens, identifying keywords, operators and other elements of the language
- semantic anlysis: checks the meaning of statements and expressions in the program, ensuring they conform to the language's rules and semantics

#### iii Identify two processes which are part of the back end.

- code optimization: optimizes the intermediate code to improve the efficiency of the generated machine code
- code generation: translates the optimized intermediate code into the target machine code for a specific architecture

#### b) Complete the following Backus–Naur definition of a signed integer:

#### i {"<Digit>"} ::=

- `<Digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9`

#### ii {"<Sign>"} ::=

- `<Sign> ::= + | -`

#### iii {"<Unsigned integer>"} ::=

- `<Unsigned integer> ::= <Digit>+`

#### iv {"<Signed integer>"} ::= [4]

- `<Signed integer> ::= <Sign>? <Unsigned integer>`

#### c) Give the Reverse Polish notation equivalent of the expression (a + 6) + b / c .

```
a6+bc/+
```

#### d) Give the infix notation equivalent of the Reverse Polish expression a 3 b _ 6 c _ - + .

```
(a+(3×b))−(6×c)
(a+3b)−6c
```

## Question 4

#### The following syntax diagrams, for a particular programming language, show the syntax of:

- #### an assignment statement
- #### a variable
- #### a letter
- #### an operator

![i1](https://cdn.discordapp.com/attachments/1163847683207856178/1184137229896011816/image.png)

#### a) The following assignment statements are invalid. Give the reason in each case.

#### i. a = b + c [1]

- `;` missing

#### ii. a = b – 2; [1]

- `2` is not a variable

#### iii. a = dd \* cce; [1]

- `e` is not a valid letter

#### b) Write the Backus-Naur Form (BNF) for the syntax diagrams shown above.

#### i. `<assignmentstatement> ::=`

```
<assignment statement> ::= <variable> = <variable><operator><variable>;
```

#### ii. `<variable> ::=`

```
<variable> ::= <letter>|<letter><letter>|<letter><letter><letter>
```

#### iii. `<letter> ::=`

```
<letter> ::= a|b|c|d
```

#### iv. `<operator> ::= [6]`

```
<operator> :: =+|-|*|÷
```

#### c) Rewrite the BNF rule for a variable so that it can be any number of letters. `<variable> ::= `

```
<variable> ::= <letter> | <letter><variable>
```

#### d) Programmers working for a software development company use both interpreters and compilers.

#### i The programmers prefer to debug their programs using an interpreter. Give one possible reason why.

- debugging is faster / easier
- can debug incomplete code
- better diagnostics

#### The company sells compiled versions of its programs. Give a reason why this helps to protect the security of the source code

- compiler produces executable version
- not readable / no need for source code
- difficult to reverse-engineer

## Question 5

#### A number of processes are being executed in a computer.

#### a) Explain the difference between a program and a process.

- A program is the written code ("static")
- A process is the executing code ("dynamic")

#### A process can be in one of three states: running, ready or blocked.

#### b) For each of the following, the process is moved from the first state to the second state. Describe the conditions that cause each of the following changes of the state of a process:

#### i From running to ready

- when process is executing it is allocated a time slice (running state)
- process is allocated time on processor
- when time slice completed process / interrupt occurs can no longer use processor even though it is capable of further processing (ready state)

#### ii From ready to running

- process is capable of using processor (ready state)
- OS allocates processor to process so that process can execute (running state)

#### iii From running to blocked

- process is executing (running state) when it needs to perform I/O operation
- placed in blocked state – until I/O operation completed

#### c) Explain why a process cannot be moved from the blocked state to the running state.

- when I/O operation completed for process in blocked state
- process put in ready state
- OS decides which process to allocate to processor from the ready queue

#### d) Explain the role of the high-level scheduler in a multiprogramming operating system.

- decides which processes are to be loaded from backing store
- into memory /ready queue
