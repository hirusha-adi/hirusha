"use strict";(self.webpackChunkhirusha=self.webpackChunkhirusha||[]).push([[1911],{7717:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>a,frontMatter:()=>l,metadata:()=>c,toc:()=>o});var i=s(1527),r=s(6213);const l={title:"Notes - Hardware and virtual machines",sidebar_label:9618,slug:9618,sidebar_position:1},t=void 0,c={id:"study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/9618",title:"Notes - Hardware and virtual machines",description:"- computer architechture:",source:"@site/docs/study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/9618.md",sourceDirName:"study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18",slug:"/study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/9618",permalink:"/docs/study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/9618",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Notes - Hardware and virtual machines",sidebar_label:"9618",slug:"9618",sidebar_position:1},sidebar:"study",previous:{title:"Chapter 18 - Hardware and virtual machines",permalink:"/docs/study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/"},next:{title:"Both",permalink:"/docs/study/cie_al/computer_science/paper_3/my_revision_notes/chapter_18/both"}},d={},o=[];function h(e){const n={img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"computer architechture:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["SIMD","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["description:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"many processors execute the same instruction using different data sets"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["MISD","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["description:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"many processors using different instrctions use the same data set"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["MIMD","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["description:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"many processors using different instructions using different data sets"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"instruction sets"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"RISC: Reduced Instruction Set Computer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"describe"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"uses simple instructions"}),"\n",(0,i.jsx)(n.li,{children:"uses a smaller instrction set"}),"\n",(0,i.jsx)(n.li,{children:"uses fixed length instructions"}),"\n",(0,i.jsx)(n.li,{children:"instructions only reqyure one clock cycle"}),"\n",(0,i.jsx)(n.li,{children:"uses single cycle instructions"}),"\n",(0,i.jsx)(n.li,{children:"limited addressing modes"}),"\n",(0,i.jsx)(n.li,{children:"uses many registers"}),"\n",(0,i.jsx)(n.li,{children:"makes use of pipelining"}),"\n",(0,i.jsx)(n.li,{children:"hardwired control unit"}),"\n",(0,i.jsx)(n.li,{children:"uses a system where cache is split between data and instructions"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"pipelining"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"how pipelining happens during fetch-execute cycle?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["answer 1","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["instructions are divided into 5 stages (subtasks)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"IF - instrution fetch"}),"\n",(0,i.jsx)(n.li,{children:"ID - instrution decode"}),"\n",(0,i.jsx)(n.li,{children:"OF - operand fetch"}),"\n",(0,i.jsx)(n.li,{children:"IE - instruction execute"}),"\n",(0,i.jsx)(n.li,{children:"WB - write back result"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"each subtask is completed during one clock cycle"}),"\n",(0,i.jsx)(n.li,{children:"no two instructions can execute their sane stage at the same clock cycle"}),"\n",(0,i.jsx)(n.li,{children:"two second instruction begins in the second clock cycle, while the first instrucftion has moved on to its second subtask"}),"\n",(0,i.jsx)(n.li,{children:"the thirs instruction beginds in the third clock cycle while the first and second instructions move on to their second and third subtasks,respectively."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["answer 2","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"pipelining allows seeveral instructions to be processed simulatneously"}),"\n",(0,i.jsxs)(n.li,{children:["therefore, increasing the cpu instruction throughput","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"the number of instructions completed per unit time"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"each instruction stage / subtask is completed during one clock cycle"}),"\n",(0,i.jsx)(n.li,{children:"no two instructions can execute their same stage of instruction / subtask at the same clock cycle"}),"\n",(0,i.jsx)(n.li,{children:"eg: wguke one instruction is being decoded, the next instruction can be fetched"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"example question:"}),"\n",(0,i.jsx)(n.p,{children:'"Complete the table to show how a program consisting of six instructions would be completed using pipelining"'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"ms1",src:s(7999).Z+"",width:"972",height:"716"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"CISC: Complex Instruction Set Computer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["describe","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"uses many instruction formats"}),"\n",(0,i.jsx)(n.li,{children:"uses variable length instructions"}),"\n",(0,i.jsx)(n.li,{children:"makes uses of different addressing modes"}),"\n",(0,i.jsx)(n.li,{children:"uses fewer registers"}),"\n",(0,i.jsx)(n.li,{children:"has a large instruction set"}),"\n",(0,i.jsx)(n.li,{children:"requires complex circuits"}),"\n",(0,i.jsx)(n.li,{children:"frequently uses cache"}),"\n",(0,i.jsx)(n.li,{children:"instructions (converted to sub instructions that) many require many clock cycles"}),"\n",(0,i.jsx)(n.li,{children:"programmable control unit"}),"\n",(0,i.jsx)(n.li,{children:"uses fewer general purpose registers"}),"\n",(0,i.jsx)(n.li,{children:"uses both hardwired and microcoded control units"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"RISC vs CISC Comparison"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"what"}),(0,i.jsx)(n.th,{children:"risc"}),(0,i.jsx)(n.th,{children:"cisc"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"registers"}),(0,i.jsx)(n.td,{children:"more"}),(0,i.jsx)(n.td,{children:"less"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"addressing modes"}),(0,i.jsx)(n.td,{children:"less"}),(0,i.jsx)(n.td,{children:"more"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"no. of instructions"}),(0,i.jsx)(n.td,{children:"small"}),(0,i.jsx)(n.td,{children:"large"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"instructions complexity"}),(0,i.jsx)(n.td,{children:"simple"}),(0,i.jsx)(n.td,{children:"complex"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"instruction cycles"}),(0,i.jsx)(n.td,{children:"single cycle instructions"}),(0,i.jsx)(n.td,{children:"multi cycle instructions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"instruction lengths"}),(0,i.jsx)(n.td,{children:"fixed length"}),(0,i.jsx)(n.td,{children:"variable length"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"pipelineability"}),(0,i.jsx)(n.td,{children:"good"}),(0,i.jsx)(n.td,{children:"bad"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"circuit complexity"}),(0,i.jsx)(n.td,{children:"less complex"}),(0,i.jsx)(n.td,{children:"more complex"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ram usage"}),(0,i.jsx)(n.td,{children:"more"}),(0,i.jsx)(n.td,{children:"less"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"control unit"}),(0,i.jsx)(n.td,{children:"hard wired"}),(0,i.jsx)(n.td,{children:"programmable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"instruction types"}),(0,i.jsx)(n.td,{children:"instructions to only load and store to memmory"}),(0,i.jsx)(n.td,{children:"has many types to address memmory"})]})]})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"process management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["sheduling","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["why? explain a need for this?","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"process sheduling allows more than one program / task to appear to be executed at the same time / enables multi-tasking and multi-programming"}),"\n",(0,i.jsx)(n.li,{children:"to allow high prioriy jobs to be completed first"}),"\n",(0,i.jsx)(n.li,{children:"to keep the cpu busy all the time"}),"\n",(0,i.jsx)(n.li,{children:"to ensure that all processes execute efficiently"}),"\n",(0,i.jsx)(n.li,{children:"and to have reduced wait times for all processes / to ensure all processes have fair access to the cpu / prevent starvation of some processes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["routines","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["shortest job first","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"process are executed in ascending order of the amount of CPU time required"}),"\n",(0,i.jsx)(n.li,{children:"short processes are executed first and followed by a longer processes"}),"\n",(0,i.jsxs)(n.li,{children:["which leads to an increased throughput","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"because more processes can be executed in a smaller amount of time"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["round robin","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["each process is served by the CPU for a fixed time (time slice)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"so all procsesses are given the same priority"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["starvation doesn't occur","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"because for each round robin cycle, every process is given a fixed time to execute"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["first come first served","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"no complex logic, each process request is queued as it is recieved and executed one by one"}),"\n",(0,i.jsx)(n.li,{children:"starvation doesn't occur (because every process will eventually get a chance to run)"}),"\n",(0,i.jsx)(n.li,{children:"less processor overhead"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"memmory management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["virtual memmory","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["explanation:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"disk / secondary storage is used to extend the ram/memmory available"}),"\n",(0,i.jsx)(n.li,{children:"so the cpu appears to be able to access more memmory space than the available RAM"}),"\n",(0,i.jsx)(n.li,{children:"only the data in uyse needs to be in the main memmor so data can be swapped between the RAM and virtual memmory as necessary"}),"\n",(0,i.jsx)(n.li,{children:"virtual memmory is created temporarily"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["paging","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"paging allows the memmory to be divided into fixed size blocks"}),"\n",(0,i.jsx)(n.li,{children:"the OS divides the memmory into pages"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["segmentation","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"divides the emmory into variable sized blocks"}),"\n",(0,i.jsx)(n.li,{children:"the compiler is responsible for calculating the segment sizes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["paging vs segmentation","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"access times for paging is fatser than for segmentation"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"virtual machines"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["what?","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"emulation of a computer system / hardware / software"}),"\n",(0,i.jsx)(n.li,{children:"using a host computer system"}),"\n",(0,i.jsx)(n.li,{children:"using guest OS for emulation"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["why?","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"emulate a new computer system"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["good:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["detailed:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["new system can be tried on different virtual hardware","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"without the need to purcahse the hardware"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["easier to recover if software emulating the new computer causes system crash","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"as VM provides protection to other software"}),"\n",(0,i.jsx)(n.li,{children:"and can restor/rollback and snapshot of the VM"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"emulate the programs for the new computer system that are not compatible with the host computer / operating system by using the guest OS on the old computer"}),"\n",(0,i.jsxs)(n.li,{children:["more than one new computer system can be emulated","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"this allowss multiple OS to co-exist on a sigle computer"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["short","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"multiple VMs can be run on the same computer simultaneously"}),"\n",(0,i.jsx)(n.li,{children:"different instruction set architechtures can be emulated on a single computer"}),"\n",(0,i.jsx)(n.li,{children:"a vm can crash without affecting the host machine"}),"\n",(0,i.jsxs)(n.li,{children:["there are security benefits","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"if we run a virus by accident, it will only infect the virtual machine"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"cost savings due to not needing to purchase extra hardware"}),"\n",(0,i.jsx)(n.li,{children:"can run legacy applications that are currently incompatible"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["bad:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["detailed:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["VM may not be able to emulate the new hardware","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"because this hardware may have been developed since the virtual machine was developed"}),"\n",(0,i.jsxs)(n.li,{children:["using virtual machine means execution of extra code","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a virtual machine machine might not be as efficient"}),"\n",(0,i.jsx)(n.li,{children:"resources and processor time are shared"}),"\n",(0,i.jsx)(n.li,{children:"processing time increased"}),"\n",(0,i.jsx)(n.li,{children:"performance degrades"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["use of a virtual machine increases the maintenance overheads","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"because both host system and the virtual machine must be maintained."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["short:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a vm has poor performance because of the extra load on the host computer"}),"\n",(0,i.jsx)(n.li,{children:"performance of the guest system cannot be adequaltely measured"}),"\n",(0,i.jsx)(n.li,{children:"a virtual machine may be affected by any weakness of the host machine"}),"\n",(0,i.jsx)(n.li,{children:"costly and complex to maintain / implement / manage"}),"\n",(0,i.jsx)(n.li,{children:"cannot emulate some hardware."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"massively parallel computers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["characteristics:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a large number of computer processors"}),"\n",(0,i.jsx)(n.li,{children:"seperate computers connected together"}),"\n",(0,i.jsx)(n.li,{children:"simultaneously performing a set of coordinated computations"}),"\n",(0,i.jsx)(n.li,{children:"collaborative processing"}),"\n",(0,i.jsx)(n.li,{children:"network infrastructure"}),"\n",(0,i.jsx)(n.li,{children:"communicate using a message interface / by sending messages"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})}function a(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},7999:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/image-e8f8ea4f215280829b2321e352c752db.png"},6213:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>t});var i=s(959);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);